<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>夏日森林的地底之风 on fordawn - a person blog</title><link>http://localhost:1313/categories/%E5%A4%8F%E6%97%A5%E6%A3%AE%E6%9E%97%E7%9A%84%E5%9C%B0%E5%BA%95%E4%B9%8B%E9%A3%8E/</link><description>Recent content in 夏日森林的地底之风 on fordawn - a person blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>fordawn</copyright><lastBuildDate>Mon, 14 Jan 2019 07:24:54 +0000</lastBuildDate><atom:link href="http://localhost:1313/categories/%E5%A4%8F%E6%97%A5%E6%A3%AE%E6%9E%97%E7%9A%84%E5%9C%B0%E5%BA%95%E4%B9%8B%E9%A3%8E/index.xml" rel="self" type="application/rss+xml"/><item><title>15. 三数之和</title><link>http://localhost:1313/post/2019/15.-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link><pubDate>Mon, 14 Jan 2019 07:24:54 +0000</pubDate><guid>http://localhost:1313/post/2019/15.-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid><description>problem 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中</description></item><item><title>139. Word Break</title><link>http://localhost:1313/post/2018/139.-word-break/</link><pubDate>Mon, 10 Sep 2018 07:53:47 +0000</pubDate><guid>http://localhost:1313/post/2018/139.-word-break/</guid><description>problem Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = &amp;ldquo;leetcode&amp;rdquo;, wordDict = [&amp;ldquo;leet&amp;rdquo;, &amp;ldquo;code&amp;rdquo;] Output: true Explanation:</description></item><item><title>191. Number of 1 Bits</title><link>http://localhost:1313/post/2018/191.-number-of-1-bits/</link><pubDate>Tue, 03 Apr 2018 17:04:18 +0000</pubDate><guid>http://localhost:1313/post/2018/191.-number-of-1-bits/</guid><description>Problem Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight). For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3. Remark 这个题总归还是很简单的。 1 2 3 4 5 6 7 8 9 10 11 12</description></item><item><title>338. Counting Bits</title><link>http://localhost:1313/post/2018/338.-counting-bits/</link><pubDate>Sat, 31 Mar 2018 18:09:51 +0000</pubDate><guid>http://localhost:1313/post/2018/338.-counting-bits/</guid><description>Problem Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&amp;rsquo;s in their binary representation and return them as an array. Example: For num = 5 you should return [0,1,1,2,1,2]. Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly</description></item><item><title>53. Maximum Subarray</title><link>http://localhost:1313/post/2018/53.-maximum-subarray/</link><pubDate>Wed, 10 Jan 2018 15:40:21 +0000</pubDate><guid>http://localhost:1313/post/2018/53.-maximum-subarray/</guid><description>problem Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class</description></item><item><title>747. Min Cost Climbing Stairs</title><link>http://localhost:1313/post/2017/747.-min-cost-climbing-stairs/</link><pubDate>Fri, 29 Dec 2017 11:39:38 +0000</pubDate><guid>http://localhost:1313/post/2017/747.-min-cost-climbing-stairs/</guid><description>problem On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. cost will have a length in the range [2, 1000]. Every cost[i]</description></item><item><title>198. House Robber</title><link>http://localhost:1313/post/2017/198.-house-robber/</link><pubDate>Sat, 11 Nov 2017 16:40:46 +0000</pubDate><guid>http://localhost:1313/post/2017/198.-house-robber/</guid><description>Question You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of</description></item><item><title>13. Roman to Integer</title><link>http://localhost:1313/post/2017/13.-roman-to-integer/</link><pubDate>Wed, 20 Sep 2017 14:50:19 +0000</pubDate><guid>http://localhost:1313/post/2017/13.-roman-to-integer/</guid><description>Question Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47</description></item><item><title>9. Palindrome Number</title><link>http://localhost:1313/post/2017/9.-palindrome-number/</link><pubDate>Sat, 09 Sep 2017 15:48:40 +0000</pubDate><guid>http://localhost:1313/post/2017/9.-palindrome-number/</guid><description>Question Determine whether an integer is a palindrome. Do this without extra space. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 bool isPalindrome(int x) { if (x &amp;lt; 0 || (x % 10 == 0 &amp;amp;&amp;amp; x != 0)) { return false; } int rev = 0; while (x &amp;gt; rev) { rev = rev * 10 + x % 10;</description></item><item><title>7. Reverse Integer</title><link>http://localhost:1313/post/2017/7.-reverse-integer/</link><pubDate>Fri, 08 Sep 2017 18:56:04 +0000</pubDate><guid>http://localhost:1313/post/2017/7.-reverse-integer/</guid><description>Question Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321 Note: The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. Solution 1 2 3 4 5 6 7 8 9 10 11 int reverse(int x) { long res = 0; while (x) { res = res * 10 + x %</description></item><item><title>Dota2 Senate</title><link>http://localhost:1313/post/2017/dota2-senate/</link><pubDate>Thu, 03 Aug 2017 16:01:21 +0000</pubDate><guid>http://localhost:1313/post/2017/dota2-senate/</guid><description>Description In the world of Dota2, there are two parties: the Radiant and the Dire. The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights: Ban one senator's right: A senator can make another</description></item><item><title>Two Sum</title><link>http://localhost:1313/post/2017/two-sum/</link><pubDate>Sat, 22 Jul 2017 00:01:29 +0000</pubDate><guid>http://localhost:1313/post/2017/two-sum/</guid><description>Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Solution 1 2 3 4 5</description></item></channel></rss>